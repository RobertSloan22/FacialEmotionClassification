<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotion Recognition</title>
    <!-- Bootstrap CSS -->

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
<style>
        body {
            padding-top: 20px;
        }
        #video {
            margin-bottom: 10px;
        }
    </style>
</head>
<body class="container">
    <h1 class="mb-4">Emotion Recognition</h1>
    <video id="video" width="720" height="560" autoplay muted></video>
    <div class="my-3">
        <button id="predictButton" class="btn btn-primary">Start Prediction</button>
        <button id="stopButton" class="btn btn-danger">Stop Prediction</button>
    </div>
    <h2 id="prediction" class="mt-3"></h2>

    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script>
        let model;
        const video = document.getElementById('video');
        const predictButton = document.getElementById('predictButton');
        const stopButton = document.getElementById('stopButton');
        const predictionElement = document.getElementById('prediction');
        const classes = ['sad', 'happy', 'neutral', 'surprise'];
        let predictionInterval;
    
        async function loadModel() {
            model = await tf.loadLayersModel('/model.json');
            console.log('Model loaded');
        }
    
        async function predict() {
            const prediction = tf.tidy(() => {
                const img = tf.browser.fromPixels(video);
                const resized = tf.image.resizeBilinear(img, [48, 48]);
                const normalized = resized.div(tf.scalar(255));
                const batched = normalized.reshape([1, 48, 48, 3]);
                return model.predict(batched);
            });
    
            const predictedClassIndex = (await prediction.argMax(1).data())[0];
            prediction.dispose(); // Dispose the prediction tensor to free memory
            const className = classes[predictedClassIndex];
            predictionElement.innerText = `Emotion: ${className}`;
        }
    
        async function enableVideo() {
            if (navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(function (stream) {
                        video.srcObject = stream;
                    })
                    .catch(function (error) {
                        console.error("Error accessing the camera: ", error);
                    });
            }
        }
    
        predictButton.addEventListener('click', () => {
            if (!model) {
                console.error('Model is not loaded yet.');
                return;
            }
            predictionInterval = setInterval(predict, 2000); // Update to predict every 2 seconds
        });
    
        stopButton.addEventListener('click', () => {
            clearInterval(predictionInterval); // Stop the prediction interval
            predictionElement.innerText = "Prediction stopped";
            console.log('Prediction stopped');
        });
    
        loadModel().then(enableVideo);
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>
